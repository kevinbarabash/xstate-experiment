/**
 * Flowtype definitions for xstate
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.10.0
 */

declare module "constants" {
  import type { ActivityMap, DefaultGuardType } from "types";

  declare export var STATE_DELIMITER: any; // "."
  declare export var EMPTY_ACTIVITY_MAP: ActivityMap;
  declare export var DEFAULT_GUARD_TYPE: DefaultGuardType;
  declare export var TARGETLESS_KEY: any; // ""
}

declare module "environment" {
  declare export var IS_PRODUCTION: boolean;
}

declare module "mapState" {
  declare export function mapState(
    stateMap: {
      [stateId: string]: any,
      ...
    },
    stateId: string
  ): any;
}

declare module "stateUtils" {
  import type { EventObject, StateNode, StateValue } from ".";

  declare type Configuration<TC, TE: EventObject> = Iterable<
    StateNode<TC, any, TE>
  >;
  declare type AdjList<TC, TE: EventObject> = Map<
    StateNode<TC, any, TE>,
    Array<StateNode<TC, any, TE>>
  >;
  declare export var isLeafNode: (
    stateNode: StateNode<any, any, any>
  ) => boolean;
  declare export function getChildren<TC, TE: EventObject>(
    stateNode: StateNode<TC, any, TE>
  ): Array<StateNode<TC, any, TE>>;

  declare export function getAllStateNodes<TC, TE: EventObject>(
    stateNode: StateNode<TC, any, TE>
  ): Array<StateNode<TC, any, TE>>;

  declare export function getConfiguration<TC, TE: EventObject>(
    prevStateNodes: Iterable<StateNode<TC, any, TE>>,
    stateNodes: Iterable<StateNode<TC, any, TE>>
  ): Iterable<StateNode<TC, any, TE>>;

  declare export function getAdjList<TC, TE: EventObject>(
    configuration: Configuration<TC, TE>
  ): AdjList<TC, TE>;

  declare export function getValue<TC, TE: EventObject>(
    rootNode: StateNode<TC, any, TE>,
    configuration: Configuration<TC, TE>
  ): StateValue;

  declare export function has<T>(iterable: Iterable<T>, item: T): boolean;

  declare export function nextEvents<TC, TE: EventObject>(
    configuration: Array<StateNode<TC, any, TE>>
  ): Array<$PropertyType<TE, "type">>;

  declare export function isInFinalState<TC, TE: EventObject>(
    configuration: Array<StateNode<TC, any, TE>>,
    stateNode: StateNode<TC, any, TE>
  ): boolean;

  declare export {};
}

declare module "actionTypes" {
  import type { ActionTypes } from "types";

  declare export var start: any; // ActionTypes$Start
  declare export var stop: any; // ActionTypes$Stop
  declare export var raise: any; // ActionTypes$Raise
  declare export var send: any; // ActionTypes$Send
  declare export var cancel: any; // ActionTypes$Cancel
  declare export var nullEvent: any; // ActionTypes$NullEvent
  declare export var assign: any; // ActionTypes$Assign
  declare export var after: any; // ActionTypes$After
  declare export var doneState: any; // ActionTypes$DoneState
  declare export var log: any; // ActionTypes$Log
  declare export var init: any; // ActionTypes$Init
  declare export var invoke: any; // ActionTypes$Invoke
  declare export var errorExecution: any; // ActionTypes$ErrorExecution
  declare export var errorPlatform: any; // ActionTypes$ErrorPlatform
  declare export var error: any; // ActionTypes$ErrorCustom
  declare export var update: any; // ActionTypes$Update
  declare export var choose: any; // ActionTypes$Choose
  declare export var pure: any; // ActionTypes$Pure
}

declare module "actions" {
  import type {
    Action,
    Event,
    EventObject,
    SingleOrArray,
    SendAction,
    SendActionOptions,
    CancelAction,
    ActionObject,
    ActionType,
    Assigner,
    PropertyAssigner,
    AssignAction,
    ActionFunction,
    ActionFunctionMap,
    ActivityActionObject,
    ActionTypes,
    ActivityDefinition,
    RaiseAction,
    RaiseActionObject,
    DoneEvent,
    ErrorPlatformEvent,
    DoneEventObject,
    SendExpr,
    SendActionObject,
    PureAction,
    LogExpr,
    LogAction,
    LogActionObject,
    DelayFunctionMap,
    SCXML,
    ExprWithMeta,
    ChooseConditon,
    ChooseAction,
    AnyEventObject,
  } from "types";

  import typeof * as actionTypes from "actionTypes";

  import type { State } from "State";

  import type { StateNode } from "StateNode";

  declare export { actionTypes };

  declare export var initEvent: SCXML$Event<{
    type: ActionTypes,
    ...
  }>;
  declare export function getActionFunction<TContext, TEvent: EventObject>(
    actionType: ActionType,
    actionFunctionMap?: ActionFunctionMap<TContext, TEvent>
  ): ActionObject<TContext, TEvent> | ActionFunction<TContext, TEvent> | void;

  declare export function toActionObject<TContext, TEvent: EventObject>(
    action: Action<TContext, TEvent>,
    actionFunctionMap?: ActionFunctionMap<TContext, TEvent>
  ): ActionObject<TContext, TEvent>;

  declare export var toActionObjects: <TContext, TEvent: EventObject>(
    action?:
      | string
      | RaiseAction<AnyEventObject>
      | ActionObject<TContext, TEvent>
      | ActionFunction<TContext, TEvent>
      | AssignAction<Required<TContext>, TEvent>
      | SendAction<TContext, TEvent, AnyEventObject>
      | ChooseAction<TContext, TEvent>
      | Action<TContext, TEvent>[]
      | void,
    actionFunctionMap?: {
      [key: string]:
        | ActionObject<TContext, TEvent>
        | ActionFunction<TContext, TEvent>,
      ...
    } | void
  ) => ActionObject<TContext, TEvent>[];
  declare export function toActivityDefinition<TContext, TEvent: EventObject>(
    action: string | ActivityDefinition<TContext, TEvent>
  ): ActivityDefinition<TContext, TEvent>;

  /**
   * Raises an event. This places the event in the internal event queue, so that
   * the event is immediately consumed by the machine in the current step.
   * @param eventType The event to raise.
   */
  declare export function raise<TContext, TEvent: EventObject>(
    event: SCXML$Event<TEvent>
  ): RaiseAction<TEvent> | SendAction<TContext, TEvent, TEvent>;

  declare export function resolveRaise<TEvent: EventObject>(
    action: RaiseAction<TEvent>
  ): RaiseActionObject<TEvent>;

  /**
   * Sends an event. This returns an action that will be read by an interpreter to
   * send the event in the next step, after the current step is finished executing.
   * @param event The event to send.
   * @param options Options to pass into the send event:
   * - `id` - The unique send event identifier (used with `cancel()`).
   * - `delay` - The number of milliseconds to delay the sending of the event.
   * - `to` - The target of this event (by default, the machine the event was sent from).
   */
  declare export function send<
    TContext,
    TEvent: EventObject,
    TSentEvent: EventObject
  >(
    event: SCXML$Event<TSentEvent> | SendExpr<TContext, TEvent, TSentEvent>,
    options?: SendActionOptions<TContext, TEvent>
  ): SendAction<TContext, TEvent, TSentEvent>;

  declare export function resolveSend<
    TContext,
    TEvent: EventObject,
    TSentEvent: EventObject
  >(
    action: SendAction<TContext, TEvent, TSentEvent>,
    ctx: TContext,
    _event: SCXML$Event<TEvent>,
    delaysMap?: DelayFunctionMap<TContext, TEvent>
  ): SendActionObject<TContext, TEvent, TSentEvent>;

  /**
   * Sends an event to this machine's parent.
   * @param event The event to send to the parent machine.
   * @param options Options to pass into the send event.
   */
  declare export function sendParent<
    TContext,
    TEvent: EventObject,
    TSentEvent: EventObject
  >(
    event: SCXML$Event<TSentEvent> | SendExpr<TContext, TEvent, TSentEvent>,
    options?: SendActionOptions<TContext, TEvent>
  ): SendAction<TContext, TEvent, TSentEvent>;

  /**
   * Sends an update event to this machine's parent.
   */
  declare export function sendUpdate<
    TContext,
    TEvent: EventObject
  >(): SendAction<
    TContext,
    TEvent,
    {
      type: typeof ActionTypes.Update,
      ...
    }
  >;

  /**
   * Sends an event back to the sender of the original event.
   * @param event The event to send back to the sender
   * @param options Options to pass into the send event
   */
  declare export function respond<
    TContext,
    TEvent: EventObject,
    TSentEvent: EventObject
  >(
    event: SCXML$Event<TEvent> | SendExpr<TContext, TEvent, TSentEvent>,
    options?: SendActionOptions<TContext, TEvent>
  ): SendAction<TContext, TEvent, AnyEventObject>;

  /**
   * @param expr The expression function to evaluate which will be logged.
   * Takes in 2 arguments:
   * - `ctx` - the current state context
   * - `event` - the event that caused this action to be executed.
   * @param label The label to give to the logged expression.
   */
  declare export function log<TContext, TEvent: EventObject>(
    expr?: string | LogExpr<TContext, TEvent>,
    label?: string
  ): LogAction<TContext, TEvent>;

  declare export var resolveLog: <TContext, TEvent: EventObject>(
    action: LogAction<TContext, TEvent>,
    ctx: TContext,
    _event: SCXML$Event<TEvent>
  ) => LogActionObject<TContext, TEvent>;

  /**
   * Cancels an in-flight `send(...)` action. A canceled sent action will not
   * be executed, nor will its event be sent, unless it has already been sent
   * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
   * @param sendId The `id` of the `send(...)` action to cancel.
   */
  declare export var cancel: (sendId: string | number) => CancelAction;

  /**
   * Starts an activity.
   * @param activity The activity to start.
   */
  declare export function start<TContext, TEvent: EventObject>(
    activity: string | ActivityDefinition<TContext, TEvent>
  ): ActivityActionObject<TContext, TEvent>;

  /**
   * Stops an activity.
   * @param activity The activity to stop.
   */
  declare export function stop<TContext, TEvent: EventObject>(
    activity: string | ActivityDefinition<TContext, TEvent>
  ): ActivityActionObject<TContext, TEvent>;

  /**
   * Updates the current context of the machine.
   * @param assignment An object that represents the partial context to update.
   */
  declare export var assign: <TContext, TEvent: EventObject>(
    assignment: Assigner<TContext, TEvent> | PropertyAssigner<TContext, TEvent>
  ) => AssignAction<TContext, TEvent>;
  declare export function isActionObject<TContext, TEvent: EventObject>(
    action: Action<TContext, TEvent>
  ): boolean;

  /**
   * Returns an event type that represents an implicit event that
   * is sent after the specified `delay`.
   * @param delayRef The delay in milliseconds
   * @param id The state node ID where this event is handled
   */
  declare export function after(delayRef: number | string, id?: string): string;

  /**
   * Returns an event that represents that a final state node
   * has been reached in the parent state node.
   * @param id The final state node's parent state node `id`
   * @param data The data to pass into the event
   */
  declare export function done(id: string, data?: any): DoneEventObject;

  /**
   * Returns an event that represents that an invoked service has terminated.
   *
   * An invoked service is terminated when it has reached a top-level final state node,
   * but not when it is canceled.
   * @param id The final state node ID
   * @param data The data to pass into the event
   */
  declare export function doneInvoke(id: string, data?: any): DoneEvent;

  declare export function error(
    id: string,
    data?: any
  ): ErrorPlatformEvent & string;

  declare export function pure<TContext, TEvent: EventObject>(
    getActions: (
      context: TContext,
      event: TEvent
    ) => SingleOrArray<ActionObject<TContext, TEvent>> | void
  ): PureAction<TContext, TEvent>;

  /**
   * Forwards (sends) an event to a specified service.
   * @param target The target service to forward the event to.
   * @param options Options to pass into the send action creator.
   */
  declare export function forwardTo<TContext, TEvent: EventObject>(
    target: $PropertyType<Required<SendActionOptions<TContext, TEvent>>, "to">,
    options?: SendActionOptions<TContext, TEvent>
  ): SendAction<TContext, TEvent, AnyEventObject>;

  /**
   * Escalates an error by sending it as an event to this machine's parent.
   * @param errorData The error data to send, or the expression function that
   * takes in the `context`, `event`, and `meta`, and returns the error data to send.
   * @param options Options to pass into the send action creator.
   */
  declare export function escalate<TContext, TEvent: EventObject, TErrorData>(
    errorData: TErrorData | ExprWithMeta<TContext, TEvent, TErrorData>,
    options?: SendActionOptions<TContext, TEvent>
  ): SendAction<TContext, TEvent, AnyEventObject>;

  declare export function choose<TContext, TEvent: EventObject>(
    conds: Array<ChooseConditon<TContext, TEvent>>
  ): ChooseAction<TContext, TEvent>;

  declare export function resolveActions<TContext, TEvent: EventObject>(
    machine: StateNode<TContext, any, TEvent>,
    currentState: State<TContext, TEvent> | void,
    currentContext: TContext,
    _event: SCXML$Event<TEvent>,
    actions: Array<ActionObject<TContext, TEvent>>
  ): [Array<ActionObject<TContext, TEvent>>, TContext];
}

declare module "State" {
  import type {
    StateValue,
    ActivityMap,
    EventObject,
    HistoryValue,
    ActionObject,
    EventType,
    StateConfig,
    SCXML,
    StateSchema,
    TransitionDefinition,
    Typestate,
  } from "types";

  import type { StateNode } from "StateNode";

  import type { Actor } from "Actor";

  declare export function stateValuesEqual(
    a: StateValue | void,
    b: StateValue | void
  ): boolean;

  declare export function isState<
    TContext,
    TEvent: EventObject,
    TStateSchema: StateSchema<TContext>,
    TTypestate: Typestate<TContext>
  >(
    state: { [key: string]: any } | string
  ): boolean;

  declare export function bindActionToState<TC, TE: EventObject>(
    action: ActionObject<TC, TE>,
    state: State<TC, TE>
  ): ActionObject<TC, TE>;

  declare export class State<
    TContext,
    TEvent: EventObject = EventObject,
    TStateSchema: StateSchema<TContext> = any,
    TTypestate: Typestate<TContext> = {
      value: any,
      context: TContext,
      ...
    }
  > {
    value: StateValue;
    context: TContext;
    historyValue?: HistoryValue | void;
    history?: State<TContext, TEvent, TStateSchema>;
    actions: Array<ActionObject<TContext, TEvent>>;
    activities: ActivityMap;
    meta: any;
    events: TEvent[];
    event: TEvent;
    _event: SCXML$Event<TEvent>;
    _sessionid: string | null;

    /**
     * Indicates whether the state has changed from the previous state. A state is considered "changed" if:
     *
     * - Its value is not equal to its previous value, or:
     * - It has any new actions (side-effects) to execute.
     *
     * An initial state (with no history) will return `undefined`.
     */
    changed: boolean | void;

    /**
     * Indicates whether the state is a final state.
     */
    done: boolean | void;

    /**
     * The enabled state nodes representative of the state value.
     */
    configuration: Array<StateNode<TContext, any, TEvent>>;

    /**
     * The next events that will cause a transition from the current state.
     */
    nextEvents: EventType[];

    /**
     * The transition definitions that resulted in this state.
     */
    transitions: Array<TransitionDefinition<TContext, TEvent>>;

    /**
     * An object mapping actor IDs to spawned actors/invoked services.
     */
    children: { [key: string]: Actor, ... };

    /**
     * Creates a new State instance for the given `stateValue` and `context`.
     * @param stateValue
     * @param context
     */
    static from<TC, TE: EventObject>(
      stateValue: State<TC, TE> | StateValue,
      context?: TC | void
    ): State<TC, TE>;

    /**
     * Creates a new State instance for the given `config`.
     * @param config The state config
     */
    static create<TC, TE: EventObject>(
      config: StateConfig<TC, TE>
    ): State<TC, TE>;

    /**
     * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).
     * @param stateValue
     * @param context
     */
    static inert<TC, TE: EventObject>(
      stateValue: State<TC, TE> | StateValue,
      context: TC
    ): State<TC, TE>;

    /**
     * Creates a new State instance.
     * @param value The state value
     * @param context The extended state
     * @param historyValue The tree representing historical values of the state nodes
     * @param history The previous state
     * @param actions An array of action objects to execute as side-effects
     * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).
     * @param meta
     * @param events Internal event queue. Should be empty with run-to-completion semantics.
     * @param configuration
     */
    constructor(config: StateConfig<TContext, TEvent>): this;

    /**
     * Returns an array of all the string leaf state node paths.
     * @param stateValue
     * @param delimiter The character(s) that separate each subpath in the string state node path.
     */
    toStrings(stateValue?: StateValue, delimiter?: string): string[];
    toJSON(): Pick<this, Exclude<$Keys<this>, "configuration" | "transitions">>;

    /**
     * Whether the current state value is a subset of the given parent state value.
     * @param parentStateValue
     */
    matches<TSV: $PropertyType<TTypestate, "value">>(
      parentStateValue: TSV
    ): boolean;
  }
}

declare module "xstate" {
  import type {
    StateMachine,
    MachineOptions,
    DefaultContext,
    MachineConfig,
    StateSchema,
    EventObject,
    AnyEventObject,
    Typestate,
  } from "types";

  declare export function Machine<TContext, TEvent: EventObject>(
    config: MachineConfig<TContext, any, TEvent>,
    options?: $Rest<MachineOptions<TContext, TEvent>, { ... }>,
    initialContext?: TContext
  ): StateMachine<TContext, any, TEvent>;

  declare export function Machine<
    TContext,
    TStateSchema: StateSchema,
    TEvent: EventObject
  >(
    config: MachineConfig<TContext, TStateSchema, TEvent>,
    options?: $Rest<MachineOptions<TContext, TEvent>, { ... }>,
    initialContext?: TContext
  ): StateMachine<TContext, TStateSchema, TEvent>;

  declare export function createMachine<
    TContext,
    TEvent: EventObject,
    TTypestate: Typestate<TContext>
  >(
    config: MachineConfig<TContext, any, TEvent>,
    options?: $Rest<MachineOptions<TContext, TEvent>, { ... }>
  ): StateMachine<TContext, any, TEvent, TTypestate>;
}

declare module "scheduler" {
  declare interface SchedulerOptions {
    deferEvents: boolean;
  }
  declare export class Scheduler {
    constructor(options?: $Rest<SchedulerOptions, { ... }>): this;
    initialize(callback?: () => void): void;
    schedule(task: () => void): void;
    clear(): void;
  }
  declare export {};
}

declare module "registry" {
  import type { Actor } from "Actor";

  declare export interface Registry {
    bookId(): string;
    register(id: string, actor: Actor): string;
    get(id: string): Actor | void;
    free(id: string): void;
  }
  declare export var registry: Registry;
}

declare module "devTools" {
  import type { Interpreter } from ".";

  declare type AnyInterpreter = Interpreter<any, any, any>;
  declare export function registerService(service: AnyInterpreter): void;

  declare export {};
}

declare module "interpreter" {
  import type {
    StateMachine,
    Event,
    EventObject,
    DefaultContext,
    StateSchema,
    StateValue,
    InterpreterOptions,
    SingleOrArray,
    DoneEvent,
    Unsubscribable,
    MachineOptions,
    SCXML,
    EventData,
    Observer,
    Spawnable,
    Typestate,
  } from "types";

  import type { State } from "State";

  import type { Actor } from "Actor";

  declare export type StateListener<
    TContext,
    TEvent: EventObject,
    TStateSchema: StateSchema<TContext> = any,
    TTypestate: Typestate<TContext> = any
  > = (
    state: State<TContext, TEvent, TStateSchema, TTypestate>,
    event: TEvent
  ) => void;
  declare export type ContextListener<TContext = DefaultContext> = (
    context: TContext,
    prevContext: TContext | void
  ) => void;
  declare export type EventListener<TEvent: EventObject = EventObject> = (
    event: TEvent
  ) => void;
  declare export type Listener = () => void;
  declare export interface Clock {
    setTimeout(fn: (...args: any[]) => void, timeout: number): any;
    clearTimeout(id: any): void;
  }
  declare interface SpawnOptions {
    name?: string;
    autoForward?: boolean;
    sync?: boolean;
  }
  declare export class Interpreter<
    TContext,
    TStateSchema: StateSchema = any,
    TEvent: EventObject = EventObject,
    TTypestate: Typestate<TContext> = any
  > mixins Actor<State<TContext, TEvent, TStateSchema, TTypestate>, TEvent> {
    machine: StateMachine<TContext, TStateSchema, TEvent, TTypestate>;

    /**
     * The default interpreter options:
     *
     * - `clock` uses the global `setTimeout` and `clearTimeout` functions
     * - `logger` uses the global `console.log()` method
     */
    static defaultOptions: InterpreterOptions;

    /**
     * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.
     */
    clock: Clock;
    options: $ReadOnly<InterpreterOptions>;

    /**
     * Whether the service is started.
     */
    initialized: boolean;
    parent?: Interpreter<any>;
    id: string;

    /**
     * The globally unique process ID for this invocation.
     */
    sessionId: string;
    children: Map<string | number, Actor>;

    /**
     * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
     * @param machine The machine to be interpreted
     * @param options Interpreter options
     */
    constructor(
      machine: StateMachine<TContext, TStateSchema, TEvent, TTypestate>,
      options?: $Rest<InterpreterOptions, { ... }>
    ): this;
    get initialState(): State<TContext, TEvent, TStateSchema, TTypestate>;
    get state(): State<TContext, TEvent, TStateSchema, TTypestate>;
    static interpret: typeof interpret;

    /**
     * Executes the actions of the given state, with that state's `context` and `event`.
     * @param state The state whose actions will be executed
     * @param actionsConfig The action implementations to use
     */
    execute(
      state: State<TContext, TEvent, TStateSchema, TTypestate>,
      actionsConfig?: $PropertyType<MachineOptions<TContext, TEvent>, "actions">
    ): void;
    onTransition(
      listener: StateListener<TContext, TEvent, TStateSchema, TTypestate>
    ): this;
    subscribe(
      observer: Observer<State<TContext, TEvent, any, TTypestate>>
    ): Unsubscribable;
    subscribe(
      nextListener?: (state: State<TContext, TEvent, any, TTypestate>) => void,
      errorListener?: (error: any) => void,
      completeListener?: () => void
    ): Unsubscribable;

    /**
     * Adds an event listener that is notified whenever an event is sent to the running interpreter.
     * @param listener The event listener
     */
    onEvent(
      listener: EventListener<>
    ): Interpreter<TContext, TStateSchema, TEvent>;

    /**
     * Adds an event listener that is notified whenever a `send` event occurs.
     * @param listener The event listener
     */
    onSend(
      listener: EventListener<>
    ): Interpreter<TContext, TStateSchema, TEvent>;

    /**
     * Adds a context listener that is notified whenever the state context changes.
     * @param listener The context listener
     */
    onChange(
      listener: ContextListener<TContext>
    ): Interpreter<TContext, TStateSchema, TEvent>;

    /**
     * Adds a listener that is notified when the machine is stopped.
     * @param listener The listener
     */
    onStop(listener: Listener): Interpreter<TContext, TStateSchema, TEvent>;

    /**
     * Adds a state listener that is notified when the statechart has reached its final state.
     * @param listener The state listener
     */
    onDone(
      listener: EventListener<DoneEvent>
    ): Interpreter<TContext, TStateSchema, TEvent>;

    /**
     * Removes a listener.
     * @param listener The listener to remove
     */
    off(
      listener: (...args: any[]) => void
    ): Interpreter<TContext, TStateSchema, TEvent>;

    /**
     * Alias for Interpreter.prototype.start
     */
    init: (
      initialState?:
        | string
        | $PropertyType<$Exports<"./types">, "StateValueMap">
        | State<TContext, TEvent, TStateSchema, TTypestate>
        | void
    ) => Interpreter<TContext, TStateSchema, TEvent, TTypestate>;

    /**
     * Starts the interpreter from the given state, or the initial state.
     * @param initialState The state to start the statechart from
     */
    start(
      initialState?:
        | State<TContext, TEvent, TStateSchema, TTypestate>
        | StateValue
    ): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;

    /**
     * Stops the interpreter and unsubscribe all listeners.
     *
     * This will also notify the `onStop` listeners.
     */
    stop(): Interpreter<TContext, TStateSchema, TEvent>;

    /**
     * Sends an event to the running interpreter to trigger a transition.
     *
     * An array of events (batched) can be sent as well, which will send all
     * batched events to the running interpreter. The listeners will be
     * notified only **once** when all events are processed.
     * @param event The event(s) to send
     */
    send: (
      event: SingleOrArray<SCXML$Event<TEvent>> | SCXML$Event<TEvent>,
      payload?: EventData | void
    ) => State<TContext, TEvent, TStateSchema, TTypestate>;

    /**
     * Returns a send function bound to this interpreter instance.
     * @param event The event to be sent by the sender.
     */
    sender(
      event: SCXML$Event<TEvent>
    ): () => State<TContext, TEvent, TStateSchema, TTypestate>;

    /**
     * Returns the next state given the interpreter's current state and the event.
     *
     * This is a pure method that does _not_ update the interpreter's state.
     * @param event The event to determine the next state
     */
    nextState(
      event: SCXML$Event<TEvent> | SCXML$Event<TEvent>
    ): State<TContext, TEvent, TStateSchema, TTypestate>;
    spawn(entity: Spawnable, name: string, options?: SpawnOptions): Actor;
    spawnMachine<TChildContext, TChildStateSchema, TChildEvent: EventObject>(
      machine: StateMachine<TChildContext, TChildStateSchema, TChildEvent>,
      options?: {
        id?: string,
        autoForward?: boolean,
        sync?: boolean,
        ...
      }
    ): Interpreter<TChildContext, TChildStateSchema, TChildEvent>;
    toJSON(): {
      id: string,
      ...
    };
  }
  declare export function spawn<TC, TE: EventObject>(
    entity: StateMachine<TC, any, TE>,
    nameOrOptions?: string | SpawnOptions
  ): Interpreter<TC, any, TE>;

  declare export function spawn(
    entity: Spawnable,
    nameOrOptions?: string | SpawnOptions
  ): Actor;

  /**
   * Creates a new Interpreter instance for the given machine with the provided options, if any.
   * @param machine The machine to interpret
   * @param options Interpreter options
   */
  declare export function interpret<
    TContext,
    TStateSchema: StateSchema,
    TEvent: EventObject,
    TTypestate: Typestate<TContext>
  >(
    machine: StateMachine<TContext, TStateSchema, TEvent, TTypestate>,
    options?: $Rest<InterpreterOptions, { ... }>
  ): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;

  declare export {};
}

declare module "match" {
  import type { State } from "State";

  import type { StateValue, EventObject } from "types";

  declare export type ValueFromStateGetter<T, TContext, TEvent: EventObject> = (
    state: State<TContext, TEvent>
  ) => T;
  declare export type StatePatternTuple<T, TContext, TEvent: EventObject> = [
    StateValue,
    ValueFromStateGetter<T, TContext, TEvent>
  ];
  declare export function matchState<T, TContext, TEvent: EventObject>(
    state: State<TContext, TEvent> | StateValue,
    patterns: Array<StatePatternTuple<T, TContext, TEvent>>,
    defaultValue: ValueFromStateGetter<T, TContext, TEvent>
  ): T;
}

declare module "index" {
  import type { matchesState } from "utils";

  import type { mapState } from "mapState";

  import type { StateNode } from "StateNode";

  import type { State } from "State";

  import type { Machine, createMachine } from "Machine";

  import type { Actor } from "Actor";

  import type {
    raise,
    send,
    sendParent,
    sendUpdate,
    log,
    start,
    stop,
    assign,
    after,
    done,
    respond,
    doneInvoke,
    forwardTo,
    escalate,
    choose,
    pure,
  } from "actions";

  import type { interpret, Interpreter, spawn } from "interpreter";

  import type { matchState } from "match";

  declare var actions: {
    raise: typeof raise,
    send: typeof send,
    sendParent: typeof sendParent,
    sendUpdate: typeof sendUpdate,
    log: typeof log,
    cancel: (
      sendId: string | number
    ) => $PropertyType<$Exports<"./types">, "CancelAction">,
    start: typeof start,
    stop: typeof stop,
    assign: <
      TContext,
      TEvent: $PropertyType<$Exports<"./types">, "EventObject">
    >(
      assignment:
        | $PropertyType<$Exports<"./types">, "Assigner">
        | $PropertyType<$Exports<"./types">, "PropertyAssigner">
    ) => $PropertyType<$Exports<"./types">, "AssignAction">,
    after: typeof after,
    done: typeof done,
    respond: typeof respond,
    forwardTo: typeof forwardTo,
    escalate: typeof escalate,
    choose: typeof choose,
    pure: typeof pure,
    ...
  };
  declare export {
    Actor,
    Machine,
    StateNode,
    State,
    matchesState,
    mapState,
    actions,
    assign,
    send,
    sendParent,
    sendUpdate,
    forwardTo,
    interpret,
    Interpreter,
    matchState,
    spawn,
    doneInvoke,
    createMachine,
  };

  declare export * from "types"
}

declare module "utils" {
  import type {
    Event,
    StateValue,
    ActionType,
    Action,
    EventObject,
    PropertyMapper,
    Mapper,
    EventType,
    HistoryValue,
    AssignAction,
    Condition,
    Subscribable,
    StateMachine,
    ConditionPredicate,
    SCXML,
    StateLike,
    EventData,
    TransitionConfig,
    TransitionConfigTarget,
    NullEvent,
    SingleOrArray,
    Guard,
  } from "types";

  import type { StateNode } from "StateNode";

  import type { State } from ".";

  import type { Actor } from "Actor";

  declare export function keys<T: { [key: string]: any }>(
    value: T
  ): Array<$Keys<T> & string>;

  declare export function matchesState(
    parentStateId: StateValue,
    childStateId: StateValue,
    delimiter?: string
  ): boolean;

  declare export function getEventType<TEvent: EventObject>(
    event: SCXML$Event<TEvent>
  ): $PropertyType<TEvent, "type">;

  declare export function getActionType(action: Action<any, any>): ActionType;

  declare export function toStatePath(
    stateId: string | string[],
    delimiter: string
  ): string[];

  declare export function isStateLike(state: any): boolean;

  declare export function toStateValue(
    stateValue: StateLike<any> | StateValue | string[],
    delimiter: string
  ): StateValue;

  declare export function pathToStateValue(statePath: string[]): StateValue;

  declare export function mapValues<T, P>(
    collection: {
      [key: string]: T,
      ...
    },
    iteratee: (
      item: T,
      key: string,
      collection: {
        [key: string]: T,
        ...
      },
      i: number
    ) => P
  ): {
    [key: string]: P,
    ...
  };

  declare export function mapFilterValues<T, P>(
    collection: {
      [key: string]: T,
      ...
    },
    iteratee: (
      item: T,
      key: string,
      collection: {
        [key: string]: T,
        ...
      }
    ) => P,
    predicate: (item: T) => boolean
  ): {
    [key: string]: P,
    ...
  };

  /**
   * Retrieves a value at the given path.
   * @param props The deep path to the prop of the desired value
   */
  declare export var path: <T: { [key: string]: any, ... }>(
    props: string[]
  ) => any;

  /**
   * Retrieves a value at the given path via the nested accessor prop.
   * @param props The deep path to the prop of the desired value
   */
  declare export function nestedPath<T: { [key: string]: any, ... }>(
    props: string[],
    accessorProp: $Keys<T>
  ): (object: T) => T;

  declare export function toStatePaths(
    stateValue: StateValue | void
  ): string[][];

  declare export function pathsToStateValue(paths: string[][]): StateValue;

  declare export function flatten<T>(array: Array<T | T[]>): T[];

  declare export function toArrayStrict<T>(value: T[] | T): T[];

  declare export function toArray<T>(value: T[] | T | void): T[];

  declare export function mapContext<TContext, TEvent: EventObject>(
    mapper:
      | Mapper<TContext, TEvent, any>
      | PropertyMapper<TContext, TEvent, any>,
    context: TContext,
    _event: SCXML$Event<TEvent>
  ): any;

  declare export function isBuiltInEvent(eventType: EventType): boolean;

  declare export function isPromiseLike(value: any): boolean;

  declare export function partition<T, A: T, B: T>(
    items: T[],
    predicate: (item: T) => boolean
  ): [A[], B[]];

  declare export function updateHistoryStates(
    hist: HistoryValue,
    stateValue: StateValue
  ): { [key: string]: HistoryValue | void, ... };

  declare export function updateHistoryValue(
    hist: HistoryValue,
    stateValue: StateValue
  ): HistoryValue;

  declare export function updateContext<TContext, TEvent: EventObject>(
    context: TContext,
    _event: SCXML$Event<TEvent>,
    assignActions: Array<AssignAction<TContext, TEvent>>,
    state?: State<TContext, TEvent>
  ): TContext;

  declare var warn: (condition: boolean | Error, message: string) => void;
  declare export { warn };

  declare export function isArray(value: any): boolean;

  declare export function isFunction(value: any): boolean;

  declare export function isString(value: any): boolean;

  declare export function toGuard<TContext, TEvent: EventObject>(
    condition?: Condition<TContext, TEvent>,
    guardMap?: { [key: string]: ConditionPredicate<TContext, TEvent>, ... }
  ): Guard<TContext, TEvent> | void;

  declare export function isObservable<T>(value: any): boolean;

  declare export var symbolObservable: string | Symbol;
  declare export function isMachine(value: any): boolean;

  declare export function isActor(value: any): boolean;

  declare export var uniqueId: () => string;
  declare export function toEventObject<TEvent: EventObject>(
    event: SCXML$Event<TEvent>,
    payload?: EventData
  ): TEvent;

  declare export function toSCXMLEvent<TEvent: EventObject>(
    event: SCXML$Event<TEvent> | SCXML$Event<TEvent>,
    scxmlEvent?: $Rest<SCXML$Event<TEvent>, { ... }>
  ): SCXML$Event<TEvent>;

  declare export function toTransitionConfigArray<
    TContext,
    TEvent: EventObject
  >(
    event:
      | $PropertyType<TEvent, "type">
      | $PropertyType<NullEvent, "type">
      | "*",
    configLike: SingleOrArray<
      | TransitionConfig<TContext, TEvent>
      | TransitionConfigTarget<TContext, TEvent>
    >
  ): Array<
    TransitionConfig<TContext, TEvent> & {
      event:
        | $PropertyType<TEvent, "type">
        | $PropertyType<NullEvent, "type">
        | "*",
      ...
    }
  >;

  declare export function normalizeTarget<TContext, TEvent: EventObject>(
    target: SingleOrArray<string | StateNode<TContext, any, TEvent>> | void
  ): Array<string | StateNode<TContext, any, TEvent>> | void;

  declare export function reportUnhandledExceptionOnInvocation(
    originalError: any,
    currentError: any,
    id: string
  ): void;

  declare export function evaluateGuard<TContext, TEvent: EventObject>(
    machine: StateNode<TContext, any, TEvent>,
    guard: Guard<TContext, TEvent>,
    context: TContext,
    _event: SCXML$Event<TEvent>,
    state: State<TContext, TEvent>
  ): boolean;
}

declare module "StateNode" {
  import type {
    Event,
    StateValue,
    StateValueMap,
    MachineOptions,
    EventObject,
    HistoryValue,
    StateNodeDefinition,
    TransitionDefinition,
    DelayedTransitionDefinition,
    ActivityDefinition,
    StateNodeConfig,
    StateSchema,
    StateNodesConfig,
    InvokeDefinition,
    ActionObject,
    Mapper,
    PropertyMapper,
    SCXML,
    Typestate,
    TransitionDefinitionMap,
  } from "types";

  import type { State } from "State";

  declare class StateNode<
    TContext = any,
    TStateSchema: StateSchema = any,
    TEvent: EventObject = EventObject,
    TTypestate: Typestate<TContext> = any
  > {
    /**
     * The raw config used to create the machine.
     */
    config: StateNodeConfig<TContext, TStateSchema, TEvent>;

    /**
     * The initial extended state
     */
    context?: $ReadOnly<TContext> | void;

    /**
     * The relative key of the state node, which represents its location in the overall state value.
     */
    key: string;

    /**
     * The unique ID of the state node.
     */
    id: string;

    /**
     * The machine's own version.
     */
    version?: string;

    /**
     * The type of this state node:
     *
     *   - `'atomic'` - no child state nodes
     *   - `'compound'` - nested child state nodes (XOR)
     *   - `'parallel'` - orthogonal nested child state nodes (AND)
     *   - `'history'` - history state node
     *   - `'final'` - final state node
     */
    type: "atomic" | "compound" | "parallel" | "final" | "history";

    /**
     * The string path from the root machine node to this node.
     */
    path: string[];

    /**
     * The initial state node key.
     */
    initial?: $Keys<$PropertyType<TStateSchema, "states">>;

    /**
     * (DEPRECATED) Whether the state node is a parallel state node.
     *
     * Use `type: 'parallel'` instead.
     */
    parallel?: boolean;

    /**
     * The child state nodes.
     */
    states: StateNodesConfig<TContext, TStateSchema, TEvent>;

    /**
     * The type of history on this state node. Can be:
     *
     *   - `'shallow'` - recalls only top-level historical state value
     *   - `'deep'` - recalls historical state value at all levels
     */
    history: false | "shallow" | "deep";

    /**
     * The action(s) to be executed upon entering the state node.
     */
    onEntry: Array<ActionObject<TContext, TEvent>>;

    /**
     * The action(s) to be executed upon exiting the state node.
     */
    onExit: Array<ActionObject<TContext, TEvent>>;

    /**
     * The activities to be started upon entering the state node,
     * and stopped upon exiting the state node.
     */
    activities: Array<ActivityDefinition<TContext, TEvent>>;
    strict: boolean;

    /**
     * The parent state node.
     */
    parent?: StateNode<TContext, any, TEvent>;

    /**
     * The root machine node.
     */
    machine: StateNode<TContext, any, TEvent>;

    /**
     * The meta data associated with this state node, which will be returned in State instances.
     */
    meta?: /* Flow doesn't support conditional types, use `$Call` utility type */ any;

    /**
     * The data sent with the "done.state._id_" event if this is a final state node.
     */
    doneData?:
      | Mapper<TContext, TEvent, any>
      | PropertyMapper<TContext, TEvent, any>;

    /**
     * The string delimiter for serializing the path to a string. The default is "."
     */
    delimiter: string;

    /**
     * The order this state node appears. Corresponds to the implicit SCXML document order.
     */
    order: number;

    /**
     * The services invoked by this state node.
     */
    invoke: Array<InvokeDefinition<TContext, TEvent>>;
    options: MachineOptions<TContext, TEvent>;
    __xstatenode: true;
    constructor(
      config: StateNodeConfig<TContext, TStateSchema, TEvent>,
      options?: $Rest<MachineOptions<TContext, TEvent>, { ... }>,
      context?: $ReadOnly<TContext> | void
    ): this;

    /**
     * Clones this state machine with custom options and context.
     * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.
     * @param context Custom context (will override predefined context)
     */
    withConfig(
      options: $Rest<MachineOptions<TContext, TEvent>, { ... }>,
      context?: TContext | void
    ): StateNode<TContext, TStateSchema, TEvent, TTypestate>;

    /**
     * Clones this state machine with custom context.
     * @param context Custom context (will override predefined context, not recursive)
     */
    withContext(context: TContext): StateNode<TContext, TStateSchema, TEvent>;

    /**
     * The well-structured state node definition.
     */
    get definition(): StateNodeDefinition<TContext, TStateSchema, TEvent>;
    toJSON(): StateNodeDefinition<TContext, TStateSchema, TEvent>;

    /**
     * The mapping of events to transitions.
     */
    get on(): TransitionDefinitionMap<TContext, TEvent>;
    get after(): Array<DelayedTransitionDefinition<TContext, TEvent>>;

    /**
     * All the transitions that can be taken from this state node.
     */
    get transitions(): Array<TransitionDefinition<TContext, TEvent>>;

    /**
     * Returns the state nodes represented by the current state value.
     * @param state The state value or State instance
     */
    getStateNodes(
      state: StateValue | State<TContext, TEvent>
    ): Array<StateNode<TContext, any, TEvent>>;

    /**
     * Returns `true` if this state node explicitly handles the given event.
     * @param event The event in question
     */
    handles(event: SCXML$Event<TEvent>): boolean;

    /**
     * Resolves the given `state` to a new `State` instance relative to this machine.
     *
     * This ensures that `.events` and `.nextEvents` represent the correct values.
     * @param state The state to resolve
     */
    resolveState(state: State<TContext, TEvent>): State<TContext, TEvent>;

    /**
     * Determines the next state given the current `state` and sent `event`.
     * @param state The current State instance or state value
     * @param event The event that was sent at the current state
     * @param context The current context (extended state) of the current state
     */
    transition(
      state:
        | string
        | StateValueMap
        | State<
            TContext,
            TEvent,
            any,
            {
              value: any,
              context: TContext,
              ...
            }
          >
        | void,
      event: SCXML$Event<TEvent> | SCXML$Event<TEvent>,
      context?: TContext
    ): State<TContext, TEvent, TStateSchema, TTypestate>;

    /**
     * Returns the child state node from its relative `stateKey`, or throws.
     */
    getStateNode(stateKey: string): StateNode<TContext, any, TEvent>;

    /**
     * Returns the state node with the given `stateId`, or throws.
     * @param stateId The state ID. The prefix "#" is removed.
     */
    getStateNodeById(stateId: string): StateNode<TContext, any, TEvent>;

    /**
     * Returns the relative state node from the given `statePath`, or throws.
     * @param statePath The string or string array relative path to the state node.
     */
    getStateNodeByPath(
      statePath: string | string[]
    ): StateNode<TContext, any, TEvent>;

    /**
     * Resolves a partial state value with its full representation in this machine.
     * @param stateValue The partial state value to resolve.
     */
    resolve(stateValue: StateValue): StateValue;
    // /* NO PRINT IMPLEMENTED: GetAccessor */ any;
    getInitialState(
      stateValue: StateValue,
      context?: TContext
    ): State<TContext, TEvent, TStateSchema, TTypestate>;

    /**
     * The initial State instance, which includes all actions to be executed from
     * entering the initial state.
     */
    get initialState(): State<TContext, TEvent, TStateSchema, TTypestate>;

    /**
     * The target state value of the history state node, if it exists. This represents the
     * default state value to transition to if no history value exists yet.
     */
    get target(): StateValue | undefined;

    /**
     * Returns the leaf nodes from a state path relative to this state node.
     * @param relativeStateId The relative state path to retrieve the state nodes
     * @param history The previous state to retrieve history
     * @param resolve Whether state nodes should resolve to initial child state nodes
     */
    getRelativeStateNodes(
      relativeStateId: StateNode<TContext, any, TEvent>,
      historyValue?: HistoryValue,
      resolve?: boolean
    ): Array<StateNode<TContext, any, TEvent>>;
    get initialStateNodes(): Array<StateNode<TContext, any, TEvent>>;

    /**
     * Retrieves state nodes from a relative path to this state node.
     * @param relativePath The relative path from this state node
     * @param historyValue
     */
    getFromRelativePath(
      relativePath: string[]
    ): Array<StateNode<TContext, any, TEvent>>;

    /**
     * All the state node IDs of this state node and its descendant state nodes.
     */
    get stateIds(): string[];

    /**
     * All the event types accepted by this state node and its descendants.
     */
    get events(): Array<TEvent>;

    /**
     * All the events that have transitions directly from this state node.
     *
     * Excludes any inert events.
     */
    get ownEvents(): Array<TEvent>;
  }
  // declare export { StateNode };
}

declare module "types" {
  import type { StateNode } from "StateNode";

  import type { State } from "State";

  import type { Interpreter, Clock } from "interpreter";

  import type { Actor } from "Actor";

  declare export type EventType = string;
  declare export type ActionType = string;
  declare export type MetaObject = { [key: string]: any, ... };

  /**
   * The full definition of an event, with a string `type`.
   */
  declare export interface EventObject {
    /**
     * The type of event that is sent.
     */
    type: string;
  }
  declare export type AnyEventObject = {
    [key: string]: any,
    ...
  } & EventObject;

  /**
   * The full definition of an action, with a string `type` and an
   * `exec` implementation function.
   */
  declare export interface ActionObject<TContext, TEvent: EventObject> {
    /**
     * The type of action that is executed.
     */
    type: string;

    /**
     * The implementation for executing the action.
     */
    exec?: ActionFunction<TContext, TEvent>;
    [other: string]: any;
  }
  declare export type DefaultContext = { [key: string]: any, ... } | void;
  declare export type EventData = { [key: string]: any, ... } & {
    type?: empty,
    ...
  };

  /**
   * The specified string event types or the specified event objects.
   */
  declare export type Event<TEvent: EventObject> =
    | $PropertyType<TEvent, "type">
    | TEvent;
  declare export type ActionMeta<TContext, TEvent: EventObject> = {
    action: ActionObject<TContext, TEvent>,
    _event: SCXML$Event<TEvent>,
    ...
  } & StateMeta<TContext, TEvent>;

  declare export interface AssignMeta<TContext, TEvent: EventObject> {
    state?: State<TContext, TEvent>;
    action: AssignAction<TContext, TEvent>;
    _event: SCXML$Event<TEvent>;
  }
  declare export type ActionFunction<TContext, TEvent: EventObject> = (
    context: TContext,
    event: TEvent,
    meta: ActionMeta<TContext, TEvent>
  ) => void;
  declare export interface ChooseConditon<TContext, TEvent: EventObject> {
    cond?: Condition<TContext, TEvent>;
    actions: Actions<TContext, TEvent>;
  }
  declare export type Action<TContext, TEvent: EventObject> =
    | ActionType
    | ActionObject<TContext, TEvent>
    | ActionFunction<TContext, TEvent>
    | AssignAction<Required<TContext>, TEvent>
    | SendAction<TContext, TEvent, AnyEventObject>
    | RaiseAction<AnyEventObject>
    | ChooseAction<TContext, TEvent>;
  declare export type Actions<TContext, TEvent: EventObject> = SingleOrArray<
    Action<TContext, TEvent>
  >;
  declare export type StateKey = string | State<any>;
  declare export interface StateValueMap {
    [key: string]: StateValue;
  }

  /**
   * The string or object representing the state value relative to the parent state node.
   *
   * - For a child atomic state node, this is a string, e.g., `"pending"`.
   * - For complex state nodes, this is an object, e.g., `{ success: "someChildState" }`.
   */
  declare export type StateValue = string | StateValueMap;
  declare export type ExtractStateValue<
    TS: StateSchema<any>,
    TSS = $PropertyType<TS, "states">
  > = /* Flow doesn't support conditional types, use `$Call` utility type */ any;
  declare export interface HistoryValue {
    states: { [key: string]: HistoryValue | void, ... };
    current: StateValue | void;
  }
  declare export type ConditionPredicate<TContext, TEvent: EventObject> = (
    context: TContext,
    event: TEvent,
    meta: GuardMeta<TContext, TEvent>
  ) => boolean;
  declare export type DefaultGuardType = "xstate.guard";
  declare export interface GuardPredicate<TContext, TEvent: EventObject> {
    type: DefaultGuardType;
    name: string | void;
    predicate: ConditionPredicate<TContext, TEvent>;
  }
  declare export type Guard<TContext, TEvent: EventObject> =
    | GuardPredicate<TContext, TEvent>
    | ({ [key: string]: any, ... } & {
        type: string,
        ...
      });
  declare export type GuardMeta<TContext, TEvent: EventObject> = {
    cond: Guard<TContext, TEvent>,
    ...
  } & StateMeta<TContext, TEvent>;

  declare export type Condition<TContext, TEvent: EventObject> =
    | string
    | ConditionPredicate<TContext, TEvent>
    | Guard<TContext, TEvent>;
  declare export type TransitionTarget<
    TContext,
    TEvent: EventObject
  > = SingleOrArray<string | StateNode<TContext, any, TEvent>>;
  declare export type TransitionTargets<TContext> = Array<
    string | StateNode<TContext, any>
  >;
  declare export interface TransitionConfig<TContext, TEvent: EventObject> {
    cond?: Condition<TContext, TEvent>;
    actions?: Actions<TContext, TEvent>;
    in?: StateValue;
    internal?: boolean;
    target?: TransitionTarget<TContext, TEvent>;
    meta?: { [key: string]: any, ... };
  }
  declare export type TargetTransitionConfig<TContext, TEvent: EventObject> = {
    target: TransitionTarget<TContext, TEvent>,
    ...
  } & TransitionConfig<TContext, TEvent>;

  declare export type ConditionalTransitionConfig<
    TContext,
    TEvent: EventObject = EventObject
  > = Array<TransitionConfig<TContext, TEvent>>;
  declare export type Transition<TContext, TEvent: EventObject = EventObject> =
    | string
    | TransitionConfig<TContext, TEvent>
    | ConditionalTransitionConfig<TContext, TEvent>;
  declare export type DisposeActivityFunction = () => void;
  declare export type ActivityConfig<TContext, TEvent: EventObject> = (
    ctx: TContext,
    activity: ActivityDefinition<TContext, TEvent>
  ) => DisposeActivityFunction | void;
  declare export type Activity<TContext, TEvent: EventObject> =
    | string
    | ActivityDefinition<TContext, TEvent>;
  declare export type ActivityDefinition<TContext, TEvent: EventObject> = {
    id: string,
    type: string,
    ...
  } & ActionObject<TContext, TEvent>;

  declare export type Sender<TEvent: EventObject> = (
    event: SCXML$Event<TEvent>
  ) => void;
  declare export type Receiver<TEvent: EventObject> = (
    listener: (event: TEvent) => void
  ) => void;
  declare export type InvokeCallback = (
    callback: Sender<any>,
    onReceive: Receiver<EventObject>
  ) => any;
  declare export interface InvokeMeta {
    data: any;
  }

  /**
   * Returns either a Promises or a callback handler (for streams of events) given the
   * machine's current `context` and `event` that invoked the service.
   *
   * For Promises, the only events emitted to the parent will be:
   * - `done.invoke.<id>` with the `data` containing the resolved payload when the promise resolves, or:
   * - `error.platform.<id>` with the `data` containing the caught error, and `src` containing the service `id`.
   *
   * For callback handlers, the `callback` will be provided, which will send events to the parent service.
   * @param context The current machine `context`
   * @param event The event that invoked the service
   */
  declare export type InvokeCreator<
    TContext,
    TEvent = AnyEventObject,
    TFinalContext = any
  > = (
    context: TContext,
    event: TEvent,
    meta: InvokeMeta
  ) =>
    | PromiseLike<TFinalContext>
    | StateMachine<TFinalContext, any, any>
    | Subscribable<any>
    | InvokeCallback;
  declare export type InvokeDefinition<TContext, TEvent: EventObject> = {
    /**
     * The source of the machine to be invoked, or the machine itself.
     */
    src: string,

    /**
     * If `true`, events sent to the parent service will be forwarded to the invoked service.
     *
     * Default: `false`
     */
    autoForward?: boolean,

    /**
     * @deprecated  Use `autoForward` property instead of `forward`. Support for `forward` will get removed in the future.
     */
    forward?: boolean,

    /**
     * Data from the parent machine's context to set as the (partial or full) context
     * for the invoked child machine.
     *
     * Data should be mapped to match the child machine's context shape.
     */
    data?:
      | Mapper<TContext, TEvent, any>
      | PropertyMapper<TContext, TEvent, any>,
    ...
  } & ActivityDefinition<TContext, TEvent>;

  declare export interface Delay {
    id: string;

    /**
     * The time to delay the event, in milliseconds.
     */
    delay: number;
  }
  declare export type DelayedTransitions<TContext, TEvent: EventObject> =
    | {
        [key: string | number]:
          | string
          | SingleOrArray<TransitionConfig<TContext, TEvent>>,
        ...
      }
    | Array<
        TransitionConfig<TContext, TEvent> & {
          delay: number | string | Expr<TContext, TEvent, number>,
          ...
        }
      >;
  declare export type StateTypes =
    | "atomic"
    | "compound"
    | "parallel"
    | "final"
    | "history"
    | string;
  declare export type SingleOrArray<T> = T[] | T;
  declare export type StateNodesConfig<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject
  > = $ObjMapi<
    $PropertyType<TStateSchema, "states">,
    <K>(
      K
    ) => StateNode<
      TContext,
      $ElementType<$PropertyType<TStateSchema, "states">, K>,
      TEvent
    >
  >;
  declare export type StatesConfig<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject
  > = $ObjMapi<
    $PropertyType<TStateSchema, "states">,
    <K>(
      K
    ) => StateNodeConfig<
      TContext,
      $ElementType<$PropertyType<TStateSchema, "states">, K>,
      TEvent
    >
  >;
  declare export type StatesDefinition<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject
  > = $ObjMapi<
    $PropertyType<TStateSchema, "states">,
    <K>(
      K
    ) => StateNodeDefinition<
      TContext,
      $ElementType<$PropertyType<TStateSchema, "states">, K>,
      TEvent
    >
  >;
  declare export type TransitionConfigTarget<TContext, TEvent: EventObject> =
    | string
    | void
    | StateNode<TContext, any, TEvent>;
  declare export type TransitionConfigOrTarget<
    TContext,
    TEvent: EventObject
  > = SingleOrArray<
    | TransitionConfigTarget<TContext, TEvent>
    | TransitionConfig<TContext, TEvent>
  >;
  declare type TransitionsConfigMap<TContext, TEvent: EventObject> = $ObjMapi<
    { [k: $PropertyType<TEvent, "type">]: any },
    <K>(
      K
    ) => TransitionConfigOrTarget<
      TContext,
      /* Flow doesn't support conditional types, use `$Call` utility type */ any
    >
  > & {
    ""?: TransitionConfigOrTarget<TContext, TEvent>,
    ...
  } & {
    "*"?: TransitionConfigOrTarget<TContext, TEvent>,
    ...
  };
  declare type TransitionsConfigArray<TContext, TEvent: EventObject> = Array<
    | $ElementType<
        $ObjMapi<
          { [k: $PropertyType<TEvent, "type">]: any },
          <K>(
            K
          ) => TransitionConfig<
            TContext,
            /* Flow doesn't support conditional types, use `$Call` utility type */ any
          > & {
            event: K,
            ...
          }
        >,
        $PropertyType<TEvent, "type">
      >
    | (TransitionConfig<TContext, TEvent> & {
        event: "",
        ...
      })
    | (TransitionConfig<TContext, TEvent> & {
        event: "*",
        ...
      })
  >;
  declare export type TransitionsConfig<TContext, TEvent: EventObject> =
    | TransitionsConfigMap<TContext, TEvent>
    | TransitionsConfigArray<TContext, TEvent>;
  declare export type InvokeConfig<TContext, TEvent: EventObject> = {
    /**
     * The unique identifier for the invoked machine. If not specified, this
     * will be the machine's own `id`, or the URL (from `src`).
     */
    id?: string,

    /**
     * The source of the machine to be invoked, or the machine itself.
     */
    src:
      | string
      | StateMachine<any, any, any>
      | InvokeCreator<TContext, TEvent, any>,

    /**
     * If `true`, events sent to the parent service will be forwarded to the invoked service.
     *
     * Default: `false`
     */
    autoForward?: boolean,

    /**
     * @deprecated  Use `autoForward` property instead of `forward`. Support for `forward` will get removed in the future.
     */
    forward?: boolean,

    /**
     * Data from the parent machine's context to set as the (partial or full) context
     * for the invoked child machine.
     *
     * Data should be mapped to match the child machine's context shape.
     */
    data?:
      | Mapper<TContext, TEvent, any>
      | PropertyMapper<TContext, TEvent, any>,

    /**
     * The transition to take upon the invoked child machine reaching its final top-level state.
     */
    onDone?:
      | string
      | SingleOrArray<TransitionConfig<TContext, DoneInvokeEvent<any>>>,

    /**
     * The transition to take upon the invoked child machine sending an error event.
     */
    onError?:
      | string
      | SingleOrArray<TransitionConfig<TContext, DoneInvokeEvent<any>>>,
    ...
  };
  declare export interface StateNodeConfig<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject
  > {
    /**
     * The relative key of the state node, which represents its location in the overall state value.
     * This is automatically determined by the configuration shape via the key where it was defined.
     */
    key?: string;

    /**
     * The initial state node key.
     */
    initial?: $Keys<$PropertyType<TStateSchema, "states">> | void;

    /**
     * @deprecated
     */
    parallel?: boolean | void;

    /**
     * The type of this state node:
     *
     *   - `'atomic'` - no child state nodes
     *   - `'compound'` - nested child state nodes (XOR)
     *   - `'parallel'` - orthogonal nested child state nodes (AND)
     *   - `'history'` - history state node
     *   - `'final'` - final state node
     */
    type?: "atomic" | "compound" | "parallel" | "final" | "history";

    /**
     * The initial context (extended state) of the machine.
     *
     * Can be an object or a function that returns an object.
     */
    context?: TContext | (() => TContext);

    /**
     * Indicates whether the state node is a history state node, and what
     * type of history:
     * shallow, deep, true (shallow), false (none), undefined (none)
     */
    history?: "shallow" | "deep" | boolean | void;

    /**
     * The mapping of state node keys to their state node configurations (recursive).
     */
    states?: StatesConfig<TContext, TStateSchema, TEvent> | void;

    /**
     * The services to invoke upon entering this state node. These services will be stopped upon exiting this state node.
     */
    invoke?: SingleOrArray<
      InvokeConfig<TContext, TEvent> | StateMachine<any, any, any>
    >;

    /**
     * The mapping of event types to their potential transition(s).
     */
    on?: TransitionsConfig<TContext, TEvent>;

    /**
     * The action(s) to be executed upon entering the state node.
     * @deprecated Use `entry` instead.
     */
    onEntry?: Actions<TContext, TEvent>;

    /**
     * The action(s) to be executed upon entering the state node.
     */
    entry?: Actions<TContext, TEvent>;

    /**
     * The action(s) to be executed upon exiting the state node.
     * @deprecated Use `exit` instead.
     */
    onExit?: Actions<TContext, TEvent>;

    /**
     * The action(s) to be executed upon exiting the state node.
     */
    exit?: Actions<TContext, TEvent>;

    /**
     * The potential transition(s) to be taken upon reaching a final child state node.
     *
     * This is equivalent to defining a `[done(id)]` transition on this state node's `on` property.
     */
    onDone?:
      | string
      | SingleOrArray<TransitionConfig<TContext, DoneEventObject>>;

    /**
     * The mapping (or array) of delays (in milliseconds) to their potential transition(s).
     * The delayed transitions are taken after the specified delay in an interpreter.
     */
    after?: DelayedTransitions<TContext, TEvent>;

    /**
     * An eventless transition that is always taken when this state node is active.
     * Equivalent to a transition specified as an empty `''`' string in the `on` property.
     */
    always?: TransitionConfigOrTarget<TContext, TEvent>;

    /**
     * The activities to be started upon entering the state node,
     * and stopped upon exiting the state node.
     */
    activities?: SingleOrArray<Activity<TContext, TEvent>>;

    /**
     * @private
     */
    parent?: StateNode<TContext, any, TEvent>;
    strict?: boolean | void;

    /**
     * The meta data associated with this state node, which will be returned in State instances.
     */
    meta?: /* Flow doesn't support conditional types, use `$Call` utility type */ any;

    /**
     * The data sent with the "done.state._id_" event if this is a final state node.
     *
     * The data will be evaluated with the current `context` and placed on the `.data` property
     * of the event.
     */
    data?:
      | Mapper<TContext, TEvent, any>
      | PropertyMapper<TContext, TEvent, any>;

    /**
     * The unique ID of the state node, which can be referenced as a transition target via the
     * `#id` syntax.
     */
    id?: string | void;

    /**
     * The string delimiter for serializing the path to a string. The default is "."
     */
    delimiter?: string;

    /**
     * The order this state node appears. Corresponds to the implicit SCXML document order.
     */
    order?: number;
  }
  declare export interface StateNodeDefinition<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject
  > {
    id: string;
    version: string | void;
    key: string;
    context: TContext;
    type: "atomic" | "compound" | "parallel" | "final" | "history";
    initial: $PropertyType<
      StateNodeConfig<TContext, TStateSchema, TEvent>,
      "initial"
    >;
    history: boolean | "shallow" | "deep" | void;
    states: StatesDefinition<TContext, TStateSchema, TEvent>;
    on: TransitionDefinitionMap<TContext, TEvent>;
    transitions: Array<TransitionDefinition<TContext, TEvent>>;
    entry: Array<ActionObject<TContext, TEvent>>;
    exit: Array<ActionObject<TContext, TEvent>>;
    activities: Array<ActivityDefinition<TContext, TEvent>>;
    meta: any;
    order: number;
    data?: $PropertyType<FinalStateNodeConfig<TContext, TEvent>, "data">;
    invoke: Array<InvokeDefinition<TContext, TEvent>>;
  }
  declare export type AnyStateNodeDefinition = StateNodeDefinition<
    any,
    any,
    any
  >;
  declare export type AtomicStateNodeConfig<TContext, TEvent: EventObject> = {
    initial?: void,
    parallel?: false | void,
    states?: void,
    onDone?: void,
    ...
  } & StateNodeConfig<TContext, StateSchema<>, TEvent>;

  declare export type HistoryStateNodeConfig<TContext, TEvent: EventObject> = {
    history: "shallow" | "deep" | true,
    target: StateValue | void,
    ...
  } & AtomicStateNodeConfig<TContext, TEvent>;

  declare export type FinalStateNodeConfig<TContext, TEvent: EventObject> = {
    type: "final",

    /**
     * The data to be sent with the "done.state.<id>" event. The data can be
     * static or dynamic (based on assigners).
     */
    data?:
      | Mapper<TContext, TEvent, any>
      | PropertyMapper<TContext, TEvent, any>,
    ...
  } & AtomicStateNodeConfig<TContext, TEvent>;

  declare export type SimpleOrStateNodeConfig<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject
  > =
    | AtomicStateNodeConfig<TContext, TEvent>
    | StateNodeConfig<TContext, TStateSchema, TEvent>;
  declare export type ActionFunctionMap<TContext, TEvent: EventObject> = {
    [key: string]:
      | ActionObject<TContext, TEvent>
      | ActionFunction<TContext, TEvent>,
    ...
  };
  declare export type DelayFunctionMap<TContext, TEvent: EventObject> = {
    [key: string]: DelayConfig<TContext, TEvent>,
    ...
  };
  declare export type ServiceConfig<TContext> =
    | string
    | StateMachine<any, any, any>
    | InvokeCreator<TContext>;
  declare export type DelayConfig<TContext, TEvent: EventObject> =
    | number
    | DelayExpr<TContext, TEvent>;
  declare export interface MachineOptions<TContext, TEvent: EventObject> {
    guards: { [key: string]: ConditionPredicate<TContext, TEvent>, ... };
    actions: ActionFunctionMap<TContext, TEvent>;
    activities: { [key: string]: ActivityConfig<TContext, TEvent>, ... };
    services: { [key: string]: ServiceConfig<TContext>, ... };
    delays: DelayFunctionMap<TContext, TEvent>;

    /**
     * @private
     */
    _parent?: StateNode<TContext, any, TEvent>;

    /**
     * @private
     */
    _key?: string;
  }
  declare export type MachineConfig<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject
  > = {
    /**
     * The initial context (extended state)
     */
    context?: TContext | (() => TContext),

    /**
     * The machine's own version.
     */
    version?: string,
    ...
  } & StateNodeConfig<TContext, TStateSchema, TEvent>;

  declare export type StandardMachineConfig<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject
  > = { ... } & StateNodeConfig<TContext, TStateSchema, TEvent>;

  declare export type ParallelMachineConfig<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject
  > = {
    initial?: void,
    type?: "parallel",
    ...
  } & StateNodeConfig<TContext, TStateSchema, TEvent>;

  declare export interface EntryExitEffectMap<TContext, TEvent: EventObject> {
    entry: Array<ActionObject<TContext, TEvent>>;
    exit: Array<ActionObject<TContext, TEvent>>;
  }
  declare export type HistoryStateNode<TContext> = {
    history: "shallow" | "deep",
    target: StateValue | void,
    ...
  } & StateNode<TContext>;

  declare export type StateMachine<
    TContext,
    TStateSchema: StateSchema<>,
    TEvent: EventObject,
    TTypestate: Typestate<TContext> = any
  > = {
    id: string,
    states: $PropertyType<StateNode<TContext, TStateSchema, TEvent>, "states">,
    ...
  } & StateNode<TContext, TStateSchema, TEvent, TTypestate>;

  declare export type StateFrom<TMachine: StateMachine<any, any, any>> = $Call<
    <R>((...args: any[]) => R) => R,
    $PropertyType<TMachine, "transition">
  >;
  declare export interface ActionMap<TContext, TEvent: EventObject> {
    onEntry: Array<Action<TContext, TEvent>>;
    actions: Array<Action<TContext, TEvent>>;
    onExit: Array<Action<TContext, TEvent>>;
  }
  declare export interface EntryExitStates<TContext> {
    entry: Set<StateNode<TContext>>;
    exit: Set<StateNode<TContext>>;
  }
  declare export interface EntryExitStateArrays<TContext> {
    entry: Array<StateNode<TContext>>;
    exit: Array<StateNode<TContext>>;
  }
  declare export interface ActivityMap {
    [activityKey: string]: ActivityDefinition<any, any> | false;
  }
  declare export interface StateTransition<TContext, TEvent: EventObject> {
    transitions: Array<TransitionDefinition<TContext, TEvent>>;
    configuration: Array<StateNode<TContext, any, TEvent>>;
    entrySet: Array<StateNode<TContext, any, TEvent>>;
    exitSet: Array<StateNode<TContext, any, TEvent>>;

    /**
     * The source state that preceded the transition.
     */
    source: State<TContext> | void;
    actions: Array<ActionObject<TContext, TEvent>>;
  }
  declare export interface TransitionData<TContext, TEvent: EventObject> {
    value: StateValue | void;
    actions: ActionMap<TContext, TEvent>;
    activities?: ActivityMap;
  }

  declare export var ActionTypes: {|
    +Start: "xstate.start", // "xstate.start"
    +Stop: "xstate.stop", // "xstate.stop"
    +Raise: "xstate.raise", // "xstate.raise"
    +Send: "xstate.send", // "xstate.send"
    +Cancel: "xstate.cancel", // "xstate.cancel"
    +NullEvent: "", // ""
    +Assign: "xstate.assign", // "xstate.assign"
    +After: "xstate.after", // "xstate.after"
    +DoneState: "done.state", // "done.state"
    +DoneInvoke: "done.invoke", // "done.invoke"
    +Log: "xstate.log", // "xstate.log"
    +Init: "xstate.init", // "xstate.init"
    +Invoke: "xstate.invoke", // "xstate.invoke"
    +ErrorExecution: "error.execution", // "error.execution"
    +ErrorCommunication: "error.communication", // "error.communication"
    +ErrorPlatform: "error.platform", // "error.platform"
    +ErrorCustom: "xstate.error", // "xstate.error"
    +Update: "xstate.update", // "xstate.update"
    +Pure: "xstate.pure", // "xstate.pure"
    +Choose: "xstate.choose", // "xstate.choose"
  |};

  declare export interface RaiseAction<TEvent: EventObject> {
    type: typeof ActionTypes.Raise;
    event: $PropertyType<TEvent, "type">;
  }
  declare export interface RaiseActionObject<TEvent: EventObject> {
    type: typeof ActionTypes.Raise;
    _event: SCXML$Event<TEvent>;
  }
  declare export type DoneInvokeEvent<TData> = {
    data: TData,
    ...
  } & EventObject;

  declare export type ErrorExecutionEvent = {
    src: string,
    type: typeof ActionTypes.ErrorExecution,
    data: any,
    ...
  } & EventObject;

  declare export type ErrorPlatformEvent = {
    data: any,
    ...
  } & EventObject;

  declare export type DoneEventObject = {
    data?: any,
    toString(): string,
    ...
  } & EventObject;

  declare export type UpdateObject = {
    id: string | number,
    state: State<any, any>,
    ...
  } & EventObject;

  declare export type DoneEvent = DoneEventObject & string;
  declare export interface NullEvent {
    type: typeof ActionTypes.NullEvent;
  }
  declare export type ActivityActionObject<TContext, TEvent: EventObject> = {
    type: typeof ActionTypes.Start | typeof ActionTypes.Stop,
    activity: ActivityDefinition<TContext, TEvent>,
    exec: ActionFunction<TContext, TEvent> | void,
    ...
  } & ActionObject<TContext, TEvent>;

  declare export type InvokeActionObject<TContext, TEvent: EventObject> = {
    activity: InvokeDefinition<TContext, TEvent>,
    ...
  } & ActivityActionObject<TContext, TEvent>;

  declare export type DelayExpr<TContext, TEvent: EventObject> = ExprWithMeta<
    TContext,
    TEvent,
    number
  >;
  declare export type LogExpr<TContext, TEvent: EventObject> = ExprWithMeta<
    TContext,
    TEvent,
    any
  >;
  declare export type LogAction<TContext, TEvent: EventObject> = {
    label: string | void,
    expr: string | LogExpr<TContext, TEvent>,
    ...
  } & ActionObject<TContext, TEvent>;

  declare export type LogActionObject<TContext, TEvent: EventObject> = {
    value: any,
    ...
  } & LogAction<TContext, TEvent>;

  declare export type SendAction<
    TContext,
    TEvent: EventObject,
    TSentEvent: EventObject
  > = {
    to:
      | string
      | number
      | Actor
      | ExprWithMeta<TContext, TEvent, string | number | Actor>
      | void,
    event: TSentEvent | SendExpr<TContext, TEvent, TSentEvent>,
    delay?: number | string | DelayExpr<TContext, TEvent>,
    id: string | number,
    ...
  } & ActionObject<TContext, TEvent>;

  declare export type SendActionObject<
    TContext,
    TEvent: EventObject,
    TSentEvent: EventObject = AnyEventObject
  > = {
    to: string | number | Actor | void,
    _event: SCXML$Event<TSentEvent>,
    event: TSentEvent,
    delay?: number,
    id: string | number,
    ...
  } & SendAction<TContext, TEvent, TSentEvent>;

  declare export type Expr<TContext, TEvent: EventObject, T> = (
    context: TContext,
    event: TEvent
  ) => T;
  declare export type ExprWithMeta<TContext, TEvent: EventObject, T> = (
    context: TContext,
    event: TEvent,
    meta: SCXMLEventMeta<TEvent>
  ) => T;
  declare export type SendExpr<
    TContext,
    TEvent: EventObject,
    TSentEvent: EventObject = AnyEventObject
  > = ExprWithMeta<TContext, TEvent, TSentEvent>;

  declare export var SpecialTargets: {|
    +Parent: "#_parent", // "#_parent"
    +Internal: "#_internal", // "#_internal"
  |};

  declare export interface SendActionOptions<TContext, TEvent: EventObject> {
    id?: string | number;
    delay?: number | string | DelayExpr<TContext, TEvent>;
    to?: string | ExprWithMeta<TContext, TEvent, string | number | Actor>;
  }
  declare export type CancelAction = {
    sendId: string | number,
    ...
  } & ActionObject<any, any>;

  declare export type Assigner<TContext, TEvent: EventObject> = (
    context: TContext,
    event: TEvent,
    meta: AssignMeta<TContext, TEvent>
  ) => $Rest<TContext, { ... }>;
  declare export type PropertyAssigner<
    TContext,
    TEvent: EventObject
  > = $ObjMapi<
    TContext,
    <K>(
      K
    ) =>
      | ((
          context: TContext,
          event: TEvent,
          meta: AssignMeta<TContext, TEvent>
        ) => $ElementType<TContext, K>)
      | $ElementType<TContext, K>
  >;
  declare export type Mapper<
    TContext,
    TEvent: EventObject,
    TParams: { ... }
  > = (context: TContext, event: TEvent) => TParams;
  declare export type PropertyMapper<
    TContext,
    TEvent: EventObject,
    TParams: { ... }
  > = $ObjMapi<
    TParams,
    <K>(
      K
    ) =>
      | ((context: TContext, event: TEvent) => $ElementType<TParams, K>)
      | $ElementType<TParams, K>
  >;
  declare export type AnyAssignAction<TContext, TEvent: EventObject> = {
    type: typeof ActionTypes.Assign,
    assignment: any,
    ...
  } & ActionObject<TContext, TEvent>;

  declare export type AssignAction<TContext, TEvent: EventObject> = {
    type: typeof ActionTypes.Assign,
    assignment: Assigner<TContext, TEvent> | PropertyAssigner<TContext, TEvent>,
    ...
  } & ActionObject<TContext, TEvent>;

  declare export type PureAction<TContext, TEvent: EventObject> = {
    type: typeof ActionTypes.Pure,
    get: (
      context: TContext,
      event: TEvent
    ) => SingleOrArray<ActionObject<TContext, TEvent>> | void,
    ...
  } & ActionObject<TContext, TEvent>;

  declare export type ChooseAction<TContext, TEvent: EventObject> = {
    type: typeof ActionTypes.Choose,
    conds: Array<ChooseConditon<TContext, TEvent>>,
    ...
  } & ActionObject<TContext, TEvent>;

  declare export type TransitionDefinition<TContext, TEvent: EventObject> = {
    target: Array<StateNode<TContext, any, TEvent>> | void,
    source: StateNode<TContext, any, TEvent>,
    actions: Array<ActionObject<TContext, TEvent>>,
    cond?: Guard<TContext, TEvent>,
    eventType:
      | $PropertyType<TEvent, "type">
      | $PropertyType<NullEvent, "type">
      | "*",
    toJSON: () => {
      target: string[] | void,
      source: string,
      actions: Array<ActionObject<TContext, TEvent>>,
      cond?: Guard<TContext, TEvent>,
      eventType:
        | $PropertyType<TEvent, "type">
        | $PropertyType<NullEvent, "type">
        | "*",
      ...
    },
    ...
  } & TransitionConfig<TContext, TEvent>;

  declare export type TransitionDefinitionMap<
    TContext,
    TEvent: EventObject
  > = $ObjMapi<
    {
      [k:
        | $PropertyType<TEvent, "type">
        | $PropertyType<NullEvent, "type">
        | "*"]: any,
    },
    <K>(
      K
    ) => Array<
      TransitionDefinition<
        TContext,
        /* Flow doesn't support conditional types, use `$Call` utility type */ any
      >
    >
  >;
  declare export type DelayedTransitionDefinition<
    TContext,
    TEvent: EventObject
  > = {
    delay: number | string | DelayExpr<TContext, TEvent>,
    ...
  } & TransitionDefinition<TContext, TEvent>;

  declare export interface Edge<
    TContext,
    TEvent: EventObject,
    TEventType: $PropertyType<TEvent, "type"> = string
  > {
    event: TEventType;
    source: StateNode<TContext, any, TEvent>;
    target: StateNode<TContext, any, TEvent>;
    cond?: Condition<
      TContext,
      TEvent & {
        type: TEventType,
        ...
      }
    >;
    actions: Array<Action<TContext, TEvent>>;
    meta?: MetaObject;
    transition: TransitionDefinition<TContext, TEvent>;
  }
  declare export interface NodesAndEdges<TContext, TEvent: EventObject> {
    nodes: StateNode[];
    edges: Array<Edge<TContext, TEvent, $PropertyType<TEvent, "type">>>;
  }
  declare export interface Segment<TContext, TEvent: EventObject> {
    /**
     * From state.
     */
    state: State<TContext, TEvent>;

    /**
     * Event from state.
     */
    event: TEvent;
  }
  declare export interface PathItem<TContext, TEvent: EventObject> {
    state: State<TContext, TEvent>;
    path: Array<Segment<TContext, TEvent>>;
    weight?: number;
  }
  declare export interface PathMap<TContext, TEvent: EventObject> {
    [key: string]: PathItem<TContext, TEvent>;
  }
  declare export interface PathsItem<TContext, TEvent: EventObject> {
    state: State<TContext, TEvent>;
    paths: Array<Array<Segment<TContext, TEvent>>>;
  }
  declare export interface PathsMap<TContext, TEvent: EventObject> {
    [key: string]: PathsItem<TContext, TEvent>;
  }
  declare export interface TransitionMap {
    state: StateValue | void;
  }
  declare export interface AdjacencyMap {
    [stateId: string]: { [key: string]: TransitionMap, ... };
  }
  declare export interface ValueAdjacencyMap<TContext, TEvent: EventObject> {
    [stateId: string]: { [key: string]: State<TContext, TEvent>, ... };
  }
  declare export interface SCXMLEventMeta<TEvent: EventObject> {
    _event: SCXML$Event<TEvent>;
  }
  declare export interface StateMeta<TContext, TEvent: EventObject> {
    state: State<TContext, TEvent>;
    _event: SCXML$Event<TEvent>;
  }
  declare export interface Typestate<TContext> {
    value: StateValue;
    context: TContext;
  }
  declare export interface StateLike<TContext> {
    value: StateValue;
    context: TContext;
    event: EventObject;
    _event: SCXML$Event<EventObject>;
  }
  declare export interface StateConfig<TContext, TEvent: EventObject> {
    value: StateValue;
    context: TContext;
    _event: SCXML$Event<TEvent>;
    _sessionid: string | null;
    historyValue?: HistoryValue | void;
    history?: State<TContext, TEvent>;
    actions?: Array<ActionObject<TContext, TEvent>>;
    activities?: ActivityMap;
    meta?: any;
    events?: TEvent[];
    configuration: Array<StateNode<TContext, any, TEvent>>;
    transitions: Array<TransitionDefinition<TContext, TEvent>>;
    children: { [key: string]: Actor, ... };
    done?: boolean;
  }
  declare export interface StateSchema<TC = any> {
    meta?: any;
    context?: $Rest<TC, { ... }>;
    states?: {
      [key: string]: StateSchema<TC>,
      ...
    };
  }
  declare export interface InterpreterOptions {
    /**
     * Whether state actions should be executed immediately upon transition. Defaults to `true`.
     */
    execute: boolean;
    clock: Clock;
    logger: (...args: any[]) => void;
    parent?: Interpreter<any, any, any>;

    /**
     * If `true`, defers processing of sent events until the service
     * is initialized (`.start()`). Otherwise, an error will be thrown
     * for events sent to an uninitialized service.
     *
     * Default: `true`
     */
    deferEvents: boolean;

    /**
     * The custom `id` for referencing this service.
     */
    id?: string;

    /**
     * If `true`, states and events will be logged to Redux DevTools.
     *
     * Default: `false`
     */
    devTools: boolean | { [key: string]: any };
    [option: string]: any;
  }
  declare interface SCXML$Event<TEvent: EventObject> {
    /**
     * This is a character string giving the name of the event.
     * The SCXML Processor must set the name field to the name of this event.
     * It is what is matched against the 'event' attribute of <transition>.
     * Note that transitions can do additional tests by using the value of this field
     * inside boolean expressions in the 'cond' attribute.
     */
    name: string;

    /**
     * This field describes the event type.
     * The SCXML Processor must set it to: "platform" (for events raised by the platform itself, such as error events),
     * "internal" (for events raised by <raise> and <send> with target '_internal')
     * or "external" (for all other events).
     */
    type: "platform" | "internal" | "external";

    /**
     * If the sending entity has specified a value for this, the Processor must set this field to that value
     * (see C Event I/O Processors for details).
     * Otherwise, in the case of error events triggered by a failed attempt to send an event,
     * the Processor must set this field to the send id of the triggering <send> element.
     * Otherwise it must leave it blank.
     */
    sendid?: string;

    /**
     * This is a URI, equivalent to the 'target' attribute on the <send> element.
     * For external events, the SCXML Processor should set this field to a value which,
     * when used as the value of 'target', will allow the receiver of the event to <send>
     * a response back to the originating entity via the Event I/O Processor specified in 'origintype'.
     * For internal and platform events, the Processor must leave this field blank.
     */
    origin?: string;

    /**
     * This is equivalent to the 'type' field on the <send> element.
     * For external events, the SCXML Processor should set this field to a value which,
     * when used as the value of 'type', will allow the receiver of the event to <send>
     * a response back to the originating entity at the URI specified by 'origin'.
     * For internal and platform events, the Processor must leave this field blank.
     */
    origintype?: string;

    /**
     * If this event is generated from an invoked child process, the SCXML Processor
     * must set this field to the invoke id of the invocation that triggered the child process.
     * Otherwise it must leave it blank.
     */
    invokeid?: string;

    /**
     * This field contains whatever data the sending entity chose to include in this event.
     * The receiving SCXML Processor should reformat this data to match its data model,
     * but must not otherwise modify it.
     *
     * If the conversion is not possible, the Processor must leave the field blank
     * and must place an error 'error.execution' in the internal event queue.
     */
    data: TEvent;

    /**
     * @private
     */
    $$type: "scxml";
  }
  declare export interface Unsubscribable {
    unsubscribe(): void;
  }
  declare export interface Subscribable<T> {
    subscribe(
      next?: (value: T) => void,
      error?: (error: any) => void,
      complete?: () => void
    ): Unsubscribable;
  }
  declare export interface Observer<T> {
    next: (value: T) => void;
    error: (err: any) => void;
    complete: () => void;
  }
  declare export type Spawnable =
    | StateMachine<any, any, any>
    | Promise<any>
    | InvokeCallback
    | Subscribable<any>;
  declare export {};
}

declare module "Actor" {
  import type {
    EventObject,
    Subscribable,
    InvokeDefinition,
    AnyEventObject,
    StateMachine,
    Spawnable,
    SCXML,
  } from "types";

  declare export type Actor<
    TContext = any,
    TEvent: EventObject = AnyEventObject
  > = {
    id: string,
    send: (event: TEvent) => any,
    stop?: () => any | void,
    toJSON: () => {
      id: string,
      ...
    },
    meta?: InvokeDefinition<TContext, TEvent>,
    state?: any,
    deferred?: boolean,
    ...
  } & Subscribable<TContext>;

  declare export function createNullActor(id: string): Actor<>;

  /**
   * Creates a deferred actor that is able to be invoked given the provided
   * invocation information in its `.meta` value.
   * @param invokeDefinition The meta information needed to invoke the actor.
   */
  declare export function createInvocableActor<TC, TE: EventObject>(
    invokeDefinition: InvokeDefinition<TC, TE>,
    machine: StateMachine<TC, any, TE>,
    context: TC,
    _event: SCXML$Event<TE>
  ): Actor<>;

  declare export function createDeferredActor(
    entity: Spawnable,
    id: string,
    data?: any
  ): Actor<>;

  declare export function isActor(item: any): boolean;
}

declare module "SimulatedClock" {
  import type { Clock } from "interpreter";

  declare export class SimulatedClock mixins SimulatedClock {
    now(): number;
    setTimeout(fn: (...args: any[]) => void, timeout: number): number;
    clearTimeout(id: number): void;
  }
}

declare module "each" {
  import type { EventObject, SingleOrArray, ActionObject } from ".";

  declare export function each<TContext, TEvent: EventObject>(
    collection: $Keys<TContext>,
    item: $Keys<TContext>,
    actions: SingleOrArray<ActionObject<TContext, TEvent>>
  ): ActionObject<TContext, TEvent>;

  declare export function each<TContext, TEvent: EventObject>(
    collection: $Keys<TContext>,
    item: $Keys<TContext>,
    index: $Keys<TContext>,
    actions: SingleOrArray<ActionObject<TContext, TEvent>>
  ): ActionObject<TContext, TEvent>;
}

declare module "invoke" {
  declare export interface InvokedPromiseOptions {
    id?: string;
  }
  declare export interface PromiseMachineSchema {
    states: {
      pending: { ... },
      resolved: { ... },
      rejected: { ... },
      ...
    };
  }
}

declare module "json" {
  import type { StateNode, ActionObject, Guard, InvokeDefinition } from "./";

  declare interface JSONFunction {
    $function: string;
  }
  declare export function stringifyFunction(fn: Function): JSONFunction;

  declare interface TransitionConfig {
    target: string[];
    source: string;
    actions: Array<ActionObject<any, any>>;
    cond: Guard<any, any> | void;
    eventType: string;
  }
  declare interface StateNodeConfig {
    type: $PropertyType<StateNode, "type">;
    id: string;
    key: string;
    initial?: string;
    entry: Array<ActionObject<any, any>>;
    exit: Array<ActionObject<any, any>>;
    on: {
      [key: string]: TransitionConfig[],
      ...
    };
    invoke: Array<InvokeDefinition<any, any>>;
    states: { [key: string]: StateNodeConfig, ... };
  }
  declare export function machineToJSON(stateNode: StateNode): StateNodeConfig;

  declare export function stringify(machine: StateNode): string;

  declare export function parse(machineString: string): StateNodeConfig;

  declare export function jsonify<T: { [key: string]: any, ... }>(value: T): T;

  declare export {};
}

declare module "patterns" {
  import type {
    AtomicStateNodeConfig,
    StatesConfig,
    Event,
    EventObject,
    StateSchema,
  } from "types";

  declare export function toggle<TEventType: string>(
    onState: string,
    offState: string,
    eventType: TEventType
  ): {
    [key: string]: AtomicStateNodeConfig<
      any,
      {
        type: TEventType,
        ...
      }
    >,
    ...
  };

  declare interface SequencePatternOptions<TEvent: EventObject> {
    nextEvent: SCXML$Event<TEvent> | void;
    prevEvent: SCXML$Event<TEvent> | void;
  }
  declare export function sequence<
    TStateSchema: StateSchema,
    TEvent: EventObject
  >(
    items: Array<$Keys<$PropertyType<TStateSchema, "states">>>,
    options?: $Rest<SequencePatternOptions<TEvent>, { ... }>
  ): {
    initial: $Keys<$PropertyType<TStateSchema, "states">>,
    states: StatesConfig<any, TStateSchema, TEvent>,
    ...
  };

  declare export {};
}

declare module "scxml" {
  import type { StateNode } from "index";

  declare export interface ScxmlToMachineOptions {
    delimiter?: string;
  }
  declare export function toMachine(
    xml: string,
    options: ScxmlToMachineOptions
  ): StateNode;
}
